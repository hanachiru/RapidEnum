using System;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace RapidEnum;

[Generator]
public class RapidEnumGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var markerProvider = context.SyntaxProvider
            .ForAttributeWithMetadataName($"{Constants.AttributeNameSpace}.{Constants.MarkerAttributeName}",
                static (node, token) =>
                {
                    token.ThrowIfCancellationRequested();
                    return node is ClassDeclarationSyntax;
                },
                static (context, token) =>
                {
                    token.ThrowIfCancellationRequested();
                    var enumSymbol = context.Attributes
                        .FirstOrDefault(x => x?.AttributeClass?.Name == Constants.MarkerAttributeName)
                        ?.ConstructorArguments.FirstOrDefault().Value as INamedTypeSymbol;
                    var accessibility = context.TargetSymbol.DeclaredAccessibility;
                    if (accessibility != Accessibility.Public && accessibility != Accessibility.Internal) return null;
                    var namespaceName = context.TargetSymbol.ContainingNamespace.IsGlobalNamespace ? null : context.TargetSymbol.ContainingNamespace.ToDisplayString();
                    return enumSymbol == null ? null : new RapidEnumGeneratorContext(enumSymbol, namespaceName, accessibility);
                }).Where(x => x != null);

        context.RegisterSourceOutput(markerProvider, static (context, generationContext) =>
        {
            if (generationContext == null)
            {
                return;
            }

            var rendered = RenderStateMachine(generationContext);
            context.AddSource(generationContext.GeneratedFileName, rendered);
        });

        var provider = context.SyntaxProvider
            .ForAttributeWithMetadataName($"{Constants.AttributeNameSpace}.{Constants.AttributeName}",
                static (node, token) =>
                {
                    token.ThrowIfCancellationRequested();
                    return node is EnumDeclarationSyntax;
                },
                static (context, token) =>
                {
                    token.ThrowIfCancellationRequested();
                    if (context.TargetSymbol is not INamedTypeSymbol enumSymbol)
                    {
                        return null;
                    }

                    var generateStateMachineAttribute = context.Attributes
                        .FirstOrDefault(x => x.AttributeClass?.Name == Constants.AttributeName);

                    if (enumSymbol.DeclaredAccessibility != Accessibility.Public &&
                        enumSymbol.DeclaredAccessibility != Accessibility.Internal) return null;
                    
                    return generateStateMachineAttribute != null
                        ? new RapidEnumGeneratorContext(enumSymbol)
                        : null;
                })
            .Where(x => x != null);

        context.RegisterSourceOutput(provider, static (context, generationContext) =>
        {
            if (generationContext == null)
            {
                return;
            }

            var rendered = RenderStateMachine(generationContext);
            context.AddSource(generationContext.GeneratedFileName, rendered);
        });
    }

    private static string RenderStateMachine(RapidEnumGeneratorContext context)
    {
        return $$$"""
                  // <auto-generated />
                  
                  using System;
                  using System.Collections.Generic;
                  using System.Runtime.CompilerServices;
                  using System.Collections.ObjectModel;
                  
                  {{{(!string.IsNullOrEmpty(context.NameSpace) ?
                      $"namespace {context.NameSpace} \n{{" :
                      "")}}}
                      
                    {{{context.Accessibility}}} static partial class {{{context.ClassName}}}
                    {
                        [MethodImpl(MethodImplOptions.AggressiveInlining)]
                        public static string ToStringFast(this {{{context.EnumFullName}}} value)
                        {
                            return value switch
                            {
                                {{{
                                    string.Join("\n              ", context.EnumNames.Select(x => $"{x} => nameof({x}),"))
                                }}}
                                _ => value.ToString()
                            };
                        }
                        
                        [MethodImpl(MethodImplOptions.AggressiveInlining)]
                        public static bool IsDefined({{{context.EnumFullName}}} value)
                        {
                            return value switch
                            {
                                {{{
                                    string.Join("\n              ", context.EnumNames.Select(x => $"{x} => true,"))
                                }}}
                                _ => false,
                            };
                        }
                        
                        [MethodImpl(MethodImplOptions.AggressiveInlining)]
                        public static bool IsDefined(string name)
                        {
                            return name switch
                            {
                                {{{
                                    string.Join("\n              ", context.EnumNames.Select(x => $"nameof({x}) => true,"))
                                }}}
                                _ => false,
                            };
                        }
                        
                        private static readonly ReadOnlyCollection<{{{context.EnumFullName}}}> CacheValues = new[]
                        {
                            {{{
                                string.Join("\n          ", context.EnumNames.Select(x => $"{x},"))
                            }}}
                        }.AsReadOnly();
                        
                        [MethodImpl(MethodImplOptions.AggressiveInlining)]
                        public static IReadOnlyList<{{{context.EnumFullName}}}> GetValues() => CacheValues;
                    
                        private static readonly ReadOnlyCollection<string> CacheNames = new[]
                        {
                            {{{
                                string.Join("\n          ", context.EnumNames.Select(x => $"nameof({x}),"))
                            }}}
                        }.AsReadOnly();
                        
                        [MethodImpl(MethodImplOptions.AggressiveInlining)]
                        public static IReadOnlyList<string> GetNames() => CacheNames;
                        
                        [MethodImpl(MethodImplOptions.AggressiveInlining)]
                        public static string GetName({{{context.EnumFullName}}} value)
                        {
                            return value.ToStringFast();
                        }
                        
                        private static readonly ReadOnlyCollection<Member> CacheMembers = new[]
                        {
                            {{{
                                string.Join("\n          ", context.EnumNames.Select(x => $"new Member(nameof({x}), {x}),"))
                            }}}
                        }.AsReadOnly();
                      
                        [MethodImpl(MethodImplOptions.AggressiveInlining)]
                        public static IReadOnlyList<Member> GetMembers() => CacheMembers;
                        
                        [MethodImpl(MethodImplOptions.AggressiveInlining)]
                        public static Member GetMember({{{context.EnumFullName}}} value)
                        {
                            return value.ToMember();
                        }
                        
                        [MethodImpl(MethodImplOptions.AggressiveInlining)]
                        public static Member ToMember(this {{{context.EnumFullName}}} value)
                        {
                            return new Member(ToStringFast(value), value);
                        }
                      
                        public sealed class Member
                        {
                            public {{{context.EnumFullName}}} Value { get; }
                            public string Name { get; }
                
                            internal Member(string name, {{{context.EnumFullName}}} value)
                            {
                                Name = name;
                                Value = value;
                            }
                        }
                        
                        [MethodImpl(MethodImplOptions.AggressiveInlining)]
                        public static {{{context.EnumFullName}}} Parse(string name, bool ignoreCase = false)
                        {
                            if (TryParse(name, out var value, ignoreCase))
                            {
                                return value;
                            }
                            throw new ArgumentException($"The value '{name}' is not defined in enum '{{{context.EnumFullName}}}'.");
                        }
                        
                        [MethodImpl(MethodImplOptions.AggressiveInlining)]
                        public static bool TryParse(
                            string name,
                            out {{{context.EnumFullName}}} value,
                            bool ignoreCase = false)
                        {
                            return ignoreCase ? TryParseIgnoreCase(name, out value) : TryParse(name, out value);
                        }
                    
                        private static bool TryParseIgnoreCase(
                            string name,
                            out {{{context.EnumFullName}}} value)
                        {
                            switch (name)
                            {
                                {{{
                                    string.Join("\n              ", context.EnumNames.Select(x => $"case not null when name.Equals(nameof({x}), StringComparison.OrdinalIgnoreCase):\n                  value = {x};\n                  return true;"))
                                }}}
                                case not null when int.TryParse(name, out var val):
                                    value = ({{{context.EnumFullName}}})val;
                                    return true;
                                default:
                                    value = default;
                                    return false;
                            }
                        }
                    
                        private static bool TryParse(
                            string name,
                            out {{{context.EnumFullName}}} value)
                        {
                            switch (name)
                            {
                                {{{
                                    string.Join("\n              ", context.EnumNames.Select(x => $"case nameof({x}):\n                   value = {x};\n                  return true;"))
                                }}}
                                case not null when int.TryParse(name, out var val):
                                    value = ({{{context.EnumFullName}}})val;
                                    return true;
                                default:
                                    value = default;
                                    return false;
                            }
                        }
                        
                        private static readonly Type CacheUnderlyingType = Enum.GetUnderlyingType(typeof({{{context.EnumFullName}}}));
                        public static Type GetUnderlyingType() => CacheUnderlyingType;
                    }
                  {{{(!string.IsNullOrEmpty(context.NameSpace) ? "}" : "")}}}
                  """;
    }
}